<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>排序算法(java) | Pang-Blog</title><meta name="description" content="排序算法(java)"><meta name="keywords" content="Java,算法"><meta name="author" content="小胖儿"><meta name="copyright" content="小胖儿"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="排序算法(java)"><meta name="twitter:description" content="排序算法(java)"><meta name="twitter:image" content="https://pangyuworld.github.io/assets/1575087132732.png"><meta property="og:type" content="article"><meta property="og:title" content="排序算法(java)"><meta property="og:url" content="https://pangyuworld.github.io/2019/04/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-java/"><meta property="og:site_name" content="Pang-Blog"><meta property="og:description" content="排序算法(java)"><meta property="og:image" content="https://pangyuworld.github.io/assets/1575087132732.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = '1'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://pangyuworld.github.io/2019/04/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-java/"><link rel="prev" title="git使用" href="https://pangyuworld.github.io/2019/04/13/git%E4%BD%BF%E7%94%A8/"><link rel="next" title="eclipse 小技巧" href="https://pangyuworld.github.io/2019/04/13/eclipse-%E5%B0%8F%E6%8A%80%E5%B7%A7/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Pang-Blog</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">49</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">60</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#算法学习（一）——排序算法"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">算法学习（一）——排序算法</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#1、冒泡排序"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">1、冒泡排序</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2、选择排序"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">2、选择排序</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3、直接插入排序"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">3、直接插入排序</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4、快速排序"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">4、快速排序</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#5、归并排序"><span class="toc_mobile_items-number">1.5.</span> <span class="toc_mobile_items-text">5、归并排序</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#6、二分插入排序"><span class="toc_mobile_items-number">1.6.</span> <span class="toc_mobile_items-text">6、二分插入排序</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#7、鸡尾酒排序"><span class="toc_mobile_items-number">1.7.</span> <span class="toc_mobile_items-text">7、鸡尾酒排序</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#算法学习（一）——排序算法"><span class="toc-number">1.</span> <span class="toc-text">算法学习（一）——排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1、冒泡排序"><span class="toc-number">1.1.</span> <span class="toc-text">1、冒泡排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2、选择排序"><span class="toc-number">1.2.</span> <span class="toc-text">2、选择排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3、直接插入排序"><span class="toc-number">1.3.</span> <span class="toc-text">3、直接插入排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4、快速排序"><span class="toc-number">1.4.</span> <span class="toc-text">4、快速排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5、归并排序"><span class="toc-number">1.5.</span> <span class="toc-text">5、归并排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6、二分插入排序"><span class="toc-number">1.6.</span> <span class="toc-text">6、二分插入排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7、鸡尾酒排序"><span class="toc-number">1.7.</span> <span class="toc-text">7、鸡尾酒排序</span></a></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(/assets/1575087132732.png)"><div id="post-info"><div id="post-title"><div class="posttitle">排序算法(java)</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2019-04-13<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2021-06-29</time><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span><span class="post-meta__separator">|</span><i class="fa fa-comments-o post-meta__icon fa-fw" aria-hidden="true"></i><span>评论数:</span><a href="/2019/04/13/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-java/#post-comment"><span class="gitalk-comment-count comment-count"></span></a></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><html><head></head><body><h1 id="算法学习（一）——排序算法"><a href="#算法学习（一）——排序算法" class="headerlink" title="算法学习（一）——排序算法"></a>算法学习（一）——排序算法</h1><p>参考：<a href="https://hrbust-acm-team.gitbooks.io/acm-book/content/basic/pai_xu.html" target="_blank" rel="noopener" title="排序">排序</a></p>
<h2 id="1、冒泡排序"><a href="#1、冒泡排序" class="headerlink" title="1、冒泡排序"></a>1、冒泡排序</h2><p>冒泡排序是一种很简单也很常见的排序算法，我们在初学编程语言，尤其是初学数组的时候，应该都了解过冒泡排序，下面就当复习吧。</p>
<a id="more"></a>

<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pubbleSprt</span><span class="params">(<span class="keyword">int</span> array[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i <= right; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j <= right-<span class="number">1</span>; j++) {</span><br><span class="line">            <span class="keyword">if</span> (array[j] > array[j + <span class="number">1</span>]) {</span><br><span class="line">                <span class="comment">//swap(array[j],array[j+1]);</span></span><br><span class="line">                <span class="keyword">int</span> cont = array[j];</span><br><span class="line">                array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">                array[j + <span class="number">1</span>] = cont;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p>冒泡排序：从数组下标left开始，依次比较相邻两个元素的值，如果前面的数大于后面的数，则互换这两个数，每轮比较之后left+1，直到left=right为止。<br>时间复杂度：$ O(n^2) $，空间复杂度： $O(n) $。</p>
<h2 id="2、选择排序"><a href="#2、选择排序" class="headerlink" title="2、选择排序"></a>2、选择排序</h2><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span> array[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> minIndex;<span class="comment">//minIndex为最大值下标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i <= right; i++) {</span><br><span class="line">        minIndex = i;<span class="comment">//minIndex默认值为排序数组初下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j <= right; j++) {</span><br><span class="line">            <span class="keyword">if</span> (array[minIndex] > array[j]) {</span><br><span class="line">                minIndex=j;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (minIndex != i) {</span><br><span class="line">            <span class="comment">//swap(array[i],array[minIndex]);</span></span><br><span class="line">            <span class="keyword">int</span> cont = array[i];</span><br><span class="line">            array[i] = array[minIndex];</span><br><span class="line">            array[minIndex] = cont;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p>时间复杂度：$ O(n^2) $，空间复杂度： $O(n) $。</p>
<h2 id="3、直接插入排序"><a href="#3、直接插入排序" class="headerlink" title="3、直接插入排序"></a>3、直接插入排序</h2><p>插入排序（Insertion Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用inplace排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> array[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = left + <span class="number">1</span>; i <= right; i++) {</span><br><span class="line">        <span class="keyword">int</span> temp = array[i];<span class="comment">//保存当前的值</span></span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j >= left && array[j] > temp) {</span><br><span class="line">            array[j + <span class="number">1</span>] = array[j];</span><br><span class="line">            j--;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//也可以改写成下面这种形式</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        while (j>=left){</span></span><br><span class="line"><span class="comment">            if (array[j]<=temp)</span></span><br><span class="line"><span class="comment">                break;</span></span><br><span class="line"><span class="comment">            array[j+1]=array[j];</span></span><br><span class="line"><span class="comment">            j--;</span></span><br><span class="line"><span class="comment">        }</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        array[j + <span class="number">1</span>] = temp;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p>时间复杂度：$ O(n^2) $，空间复杂度： $O(n) $。</p>
<h2 id="4、快速排序"><a href="#4、快速排序" class="headerlink" title="4、快速排序"></a>4、快速排序</h2><p>上面写了三个排序以后，终于到了快排了。快排怎么说呢，是我认为高级排序算法里面我能够理解的一类简单算法了。<br>快排的基本思想其实也很简单，大概就是分治法（分治是啥我也不太懂）。<br>基本思想：从序列中选出一个关键字，然后根据关键字将序列分成两部分（比关键字大、比关键字小），然后将左右两侧的序列分别按照刚才的方法对其进行排序，直到序列不可再分为止。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> array[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>{</span><br><span class="line">   <span class="keyword">if</span> (left >= right)<span class="comment">//如果左边界大于右边界，则停止递归</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i = left, j = right;<span class="comment">//获取左右边界</span></span><br><span class="line">    <span class="keyword">int</span> temp = array[i];<span class="comment">//取序列第一个值为参考值</span></span><br><span class="line">    <span class="keyword">while</span> (i < j) {</span><br><span class="line">        <span class="keyword">while</span> (i < j && array[j] >= temp) {</span><br><span class="line">            j--;</span><br><span class="line">        }</span><br><span class="line">        array[i] = array[j];</span><br><span class="line">        <span class="keyword">while</span> (i < j && array[i] <= temp) {</span><br><span class="line">            i++;</span><br><span class="line">        }</span><br><span class="line">        array[j] = array[i];</span><br><span class="line">    }</span><br><span class="line">    array[i] = temp;</span><br><span class="line">    quickSort(array, left, i - <span class="number">1</span>);<span class="comment">//递归左边</span></span><br><span class="line">    quickSort(array, i + <span class="number">1</span>, right);<span class="comment">//递归右边</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p>时间复杂度：$ O(nlog(n)) $，空间复杂度： $O(n) $。<br>这里可以看到，快速排序的时间复杂度要比前三种排序方法低了很多。</p>
<h2 id="5、归并排序"><a href="#5、归并排序" class="headerlink" title="5、归并排序"></a>5、归并排序</h2><p>归并排序是一种稳定的算法，采用分治的思想，有序的子序列合并得到有序序列。<br>实现步骤：<br>1、将序列分成长度为 n/2的两部分<br>2、对于左右两部分采用分治的方法得到有序序列<br>3、将左右两个有序序列合并得到整个有序序列<br><a href="https://hrbust-acm-team.gitbooks.io/acm-book/content/basic/%E5%9B%BE%E7%89%872.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="归并排序算法" class="fancybox"><img alt="归并排序算法" title="归并排序算法" data-src="https://hrbust-acm-team.gitbooks.io/acm-book/content/basic/%E5%9B%BE%E7%89%872.png" class="lazyload"></a></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">splitArray</span><span class="params">(<span class="keyword">int</span> array[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>{</span><br><span class="line">    <span class="comment">//拆分</span></span><br><span class="line">    <span class="keyword">if</span> (left >= right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    splitArray(array, left, mid);<span class="comment">//递归拆分左边</span></span><br><span class="line">    splitArray(array, mid + <span class="number">1</span>, right);<span class="comment">//递归拆分右边</span></span><br><span class="line">    mergeArray(array, left, mid, right);<span class="comment">//实现归并</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeArray</span><span class="params">(<span class="keyword">int</span> array[], <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>{</span><br><span class="line">    <span class="comment">//归并</span></span><br><span class="line">    <span class="keyword">if</span> (left > right)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i = left, j = mid + <span class="number">1</span>;<span class="comment">//设置两个起始点</span></span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;<span class="comment">//新数组的下标</span></span><br><span class="line">    <span class="keyword">int</span> temp[]=<span class="keyword">new</span> <span class="keyword">int</span>[right-left+<span class="number">1</span>];<span class="comment">//新建一个数组，保存数据</span></span><br><span class="line">    <span class="keyword">while</span> (i<=mid&&j<=right){<span class="comment">//把较小的数存入数组</span></span><br><span class="line">        <span class="keyword">if</span> (array[i]<array[j]){< span><br><span class="line">            temp[index++]=array[i++];</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            temp[index++]=array[j++];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (i<=mid){<span class="comment">//把左数组放入新数组</span></span><br><span class="line">        temp[index++]=array[i++];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (j<=right){<span class="comment">//把右数组放入新数组</span></span><br><span class="line">        temp[index++]=array[j++];</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//将新数组覆盖掉旧数组</span></span><br><span class="line">    index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left<=right){</span><br><span class="line">        array[left++]=temp[index++];</span><br><span class="line">    }</span><br><span class="line">}</span><br></array[j]){<></span></pre></td></tr></tbody></table></figure></div>

<p><em>PS：不简单啊，归并算法看了好久好久然后才写出来，一直想找一个不用新建数组的方法，但是最后还是没有找到，用数组也搞了很久，不过还好，认识到了归并怎么用了</em><br>时间复杂度：$ O(nlog(n)) $，空间复杂度： $O(n) $。</p>
<h2 id="6、二分插入排序"><a href="#6、二分插入排序" class="headerlink" title="6、二分插入排序"></a>6、二分插入排序</h2><p>二分（折半）插入（Binary insert sort)排序是一种在直接插入排序算法上进行小改动的排序算法。其与直接排序算法最大的区别在于查找插入位置时使用的是二分查找的方式，在速度上有一定提升。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binaryInsertSort</span><span class="params">(<span class="keyword">int</span> array[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=left+<span class="number">1</span>;i<=right;i++){</span><br><span class="line">        <span class="keyword">int</span> low=left,high=i-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low<=high){<span class="comment">//利用二分法找到要插入的地方</span></span><br><span class="line">            <span class="keyword">int</span> mid=(high+low)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (array[mid]>array[i]){</span><br><span class="line">                high=mid-<span class="number">1</span>;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                low=mid+<span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> temp=array[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i;j>high+<span class="number">1</span>;j--){</span><br><span class="line">            array[j]=array[j-<span class="number">1</span>];</span><br><span class="line">        }</span><br><span class="line">        array[high+<span class="number">1</span>]=temp;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p>时间复杂度：$ O(n^2) $，空间复杂度： $O(n) $。</p>
<h2 id="7、鸡尾酒排序"><a href="#7、鸡尾酒排序" class="headerlink" title="7、鸡尾酒排序"></a>7、鸡尾酒排序</h2><p>鸡尾酒排序等于是冒泡排序的轻微变形。不同的地方在于从低到高然后从高到低，而冒泡排序则仅从低到高去比较序列里的每个元素。他可以得到比冒泡排序稍微好一点的效能，原因是冒泡排序只从一个方向进行比对(由低到高)，每次循环只移动一个项目。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cocktailSort</span><span class="params">(<span class="keyword">int</span> array[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> low=left,high=right;<span class="comment">//初始化边界</span></span><br><span class="line">    <span class="keyword">while</span> (low<high){< span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=low;i<high;i++){< span><br><span class="line">            <span class="keyword">if</span> (array[i]>array[i+<span class="number">1</span>]){</span><br><span class="line">                <span class="keyword">int</span> cont=array[i];</span><br><span class="line">                array[i]=array[i+<span class="number">1</span>];</span><br><span class="line">                array[i+<span class="number">1</span>]=cont;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        high--;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=high;i>low;i--){</span><br><span class="line">            <span class="keyword">if</span> (array[i]<array[i-<span class="number">1</array[i-<span></span>]){</high;i++){<></span><br><span class="line">                <span class="keyword">int</span> cont=array[i];</span><br><span class="line">                array[i]=array[i-<span class="number">1</span>];</span><br><span class="line">                array[i-<span class="number">1</span>]=cont;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        low++;</span><br><span class="line">    }</span><br><span class="line">}</span><br></high){<></span></pre></td></tr></tbody></table></figure></div>

<p>时间复杂度：小于 $O(n^2)$ 且大于 $O(n)$ 。</p>
</body></html></div></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java    </a><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法    </a></div><div class="post_share"><div class="social-share" data-image="/assets/1575087132732.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.png" alt="微信"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2019/04/13/git%E4%BD%BF%E7%94%A8/"><img class="prev_cover lazyload" data-src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1575097580565&amp;di=0331a0672f5fdf2cd6ceeadda21b4d34&amp;imgtype=0&amp;src=http%3A%2F%2Fi1.hdslb.com%2Fbfs%2Farchive%2Feb419fc6b38007d4155c2309b56c11018b85ad77.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>git使用</span></div></a></div><div class="next-post pull_right"><a href="/2019/04/13/eclipse-%E5%B0%8F%E6%8A%80%E5%B7%A7/"><img class="next_cover lazyload" data-src="http://img4.imgtn.bdimg.com/it/u=1376956266,2651901568&amp;fm=26&amp;gp=0.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>eclipse 小技巧</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/11/13/深入java基础（1）/" title="深入java基础（1）--安装java"><img class="relatedPosts_cover lazyload"data-src="/assets/深入java基础（1）/timg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-11-13</div><div class="relatedPosts_title">深入java基础（1）--安装java</div></div></a></div><div class="relatedPosts_item"><a href="/2019/04/03/Java中try-参数-语句中的参数意义/" title="Java中try(参数){}语句中的参数意义"><img class="relatedPosts_cover lazyload"data-src="/assets/1575087573085.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-04-03</div><div class="relatedPosts_title">Java中try(参数){}语句中的参数意义</div></div></a></div><div class="relatedPosts_item"><a href="/2019/04/03/Java玄学之类反射机制/" title="Java玄学之类反射机制"><img class="relatedPosts_cover lazyload"data-src="/assets/1575087573085.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-04-03</div><div class="relatedPosts_title">Java玄学之类反射机制</div></div></a></div><div class="relatedPosts_item"><a href="/2019/04/03/Spring-Boot-No-identifier-specified-for-entity报错解决办法/" title="Spring Boot: No identifier specified for entity报错解决办法"><img class="relatedPosts_cover lazyload"data-src="/assets/u=2656353677,2997395625&fm=26&gp=0.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-04-03</div><div class="relatedPosts_title">Spring Boot: No identifier specified for entity报错解决办法</div></div></a></div><div class="relatedPosts_item"><a href="/2019/04/13/eclipse-小技巧/" title="eclipse 小技巧"><img class="relatedPosts_cover lazyload"data-src="http://img4.imgtn.bdimg.com/it/u=1376956266,2651901568&fm=26&gp=0.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-04-13</div><div class="relatedPosts_title">eclipse 小技巧</div></div></a></div><div class="relatedPosts_item"><a href="/2019/04/03/instanceof运算符/" title="instanceof运算符"><img class="relatedPosts_cover lazyload"data-src="/assets/1575087573085.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-04-03</div><div class="relatedPosts_title">instanceof运算符</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '29b42fd6892324c6f96e',
  clientSecret: '5057141e64d6998667ed7475126857372b8285b6',
  repo: 'pangyuworld.github.io',
  owner: 'pangyuworld',
  admin: 'pangyuworld',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN',
  updateCountCallback: commentCount
})
gitalk.render('gitalk-container')

function commentCount(n){
  document.getElementsByClassName('gitalk-comment-count')[0].innerHTML= n
}</script></div></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By 小胖儿</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://xiaopangemm.coding.me/" target="_blank" rel="noopener">blog</a>!</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":250,"height":500},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>