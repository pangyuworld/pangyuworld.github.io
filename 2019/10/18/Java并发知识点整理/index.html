<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>Java并发知识点整理（1） | Pang-Blog</title><meta name="description" content="Java并发知识点整理（1）"><meta name="keywords" content="Java,高并发"><meta name="author" content="小胖儿"><meta name="copyright" content="小胖儿"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Java并发知识点整理（1）"><meta name="twitter:description" content="Java并发知识点整理（1）"><meta name="twitter:image" content="https://pangyuworld.github.io/assets/1575087573085.png"><meta property="og:type" content="article"><meta property="og:title" content="Java并发知识点整理（1）"><meta property="og:url" content="https://pangyuworld.github.io/2019/10/18/Java%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"><meta property="og:site_name" content="Pang-Blog"><meta property="og:description" content="Java并发知识点整理（1）"><meta property="og:image" content="https://pangyuworld.github.io/assets/1575087573085.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = '1'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://pangyuworld.github.io/2019/10/18/Java%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"><link rel="prev" title="IntelliJ IDEA--打造最强大的Java-IDE" href="https://pangyuworld.github.io/2019/11/01/IntelliJ-IDEA-%E6%89%93%E9%80%A0%E6%9C%80%E5%BC%BA%E5%A4%A7%E7%9A%84Java-IDE/"><link rel="next" title="常用简单sql语句(入门用)" href="https://pangyuworld.github.io/2019/10/17/%E5%B8%B8%E7%94%A8%E7%AE%80%E5%8D%95sql%E8%AF%AD%E5%8F%A5-%E5%85%A5%E9%97%A8%E7%94%A8/"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">Pang-Blog</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">49</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">60</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#一、Java创建线程的四种方式"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">一、Java创建线程的四种方式</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#1-继承Thread类实现多线程"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">1. 继承Thread类实现多线程</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-实现Runnable接口实现多线程"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">2. 实现Runnable接口实现多线程</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-实现Callable接口实现多线程（jdk1-5以后）"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">3. 实现Callable接口实现多线程（jdk1.5以后）</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-创建线程池"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">4. 创建线程池</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#二、Thread类详解"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">二、Thread类详解</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#1-构造方法"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">1. 构造方法</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-1-Thread"><span class="toc_mobile_items-number">2.1.1.</span> <span class="toc_mobile_items-text">1.1 Thread()</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-2-Thread-Runnable-target"><span class="toc_mobile_items-number">2.1.2.</span> <span class="toc_mobile_items-text">1.2 Thread(Runnable target)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-3-Thread-Runnable-target-String-name"><span class="toc_mobile_items-number">2.1.3.</span> <span class="toc_mobile_items-text">1.3 Thread(Runnable target, String name)</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-static-Thread-currentThread"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">2. static Thread currentThread()</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-获取线程信息"><span class="toc_mobile_items-number">2.3.</span> <span class="toc_mobile_items-text">3. 获取线程信息</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#3-1-public-long-getId"><span class="toc_mobile_items-number">2.3.1.</span> <span class="toc_mobile_items-text">3.1 public long getId()</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#3-2-public-String-getName"><span class="toc_mobile_items-number">2.3.2.</span> <span class="toc_mobile_items-text">3.2 public String getName()</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#3-3-public-int-getStackTrace"><span class="toc_mobile_items-number">2.3.3.</span> <span class="toc_mobile_items-text">3.3 public int getStackTrace()</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#3-4-public-boolean-isDaemon"><span class="toc_mobile_items-number">2.3.4.</span> <span class="toc_mobile_items-text">3.4 public boolean isDaemon()</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-线程控制"><span class="toc_mobile_items-number">2.4.</span> <span class="toc_mobile_items-text">4. 线程控制</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#4-1-public-void-start"><span class="toc_mobile_items-number">2.4.1.</span> <span class="toc_mobile_items-text">4.1 public void start()</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#4-2-public-void-join-public-void-join-long-millis"><span class="toc_mobile_items-number">2.4.2.</span> <span class="toc_mobile_items-text">4.2 public void join()&#x2F;public void join(long millis)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#4-3-public-static-void-sleep-long-millis"><span class="toc_mobile_items-number">2.4.3.</span> <span class="toc_mobile_items-text">4.3 public static void sleep(long millis)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#4-4-其他控制线程的方法"><span class="toc_mobile_items-number">2.4.4.</span> <span class="toc_mobile_items-text">4.4 其他控制线程的方法</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#Object-wait-Object-wait-long-timeout"><span class="toc_mobile_items-number">2.4.4.1.</span> <span class="toc_mobile_items-text">Object.wait()&#x2F;Object.wait(long timeout)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#Object-notify-Object-notifyAll"><span class="toc_mobile_items-number">2.4.4.2.</span> <span class="toc_mobile_items-text">Object.notify()&#x2F;Object.notifyAll()</span></a></li></ol></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#三、同步（并发）问题"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">三、同步（并发）问题</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#1-产生同步问题的案例"><span class="toc_mobile_items-number">3.1.</span> <span class="toc_mobile_items-text">1. 产生同步问题的案例</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-解决多线程同步问题-synchronized"><span class="toc_mobile_items-number">3.2.</span> <span class="toc_mobile_items-text">2. 解决多线程同步问题-synchronized</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-解决多线程同步问题-java-util-concurrent-Lock"><span class="toc_mobile_items-number">3.3.</span> <span class="toc_mobile_items-text">3. 解决多线程同步问题-java.util.concurrent.Lock</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#4-剖析产生并发问题的原因"><span class="toc_mobile_items-number">3.4.</span> <span class="toc_mobile_items-text">4. 剖析产生并发问题的原因</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#四、锁"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">四、锁</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#1-什么是锁"><span class="toc_mobile_items-number">4.1.</span> <span class="toc_mobile_items-text">1. 什么是锁</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-理解synchronized关键字"><span class="toc_mobile_items-number">4.2.</span> <span class="toc_mobile_items-text">2. 理解synchronized关键字</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#3-显示锁java-util-concurrent-Lock"><span class="toc_mobile_items-number">4.3.</span> <span class="toc_mobile_items-text">3. 显示锁java.util.concurrent.Lock</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#3-1-java-concurrent-locks-Condition类"><span class="toc_mobile_items-number">4.3.1.</span> <span class="toc_mobile_items-text">3.1 java.concurrent.locks.Condition类</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#五、关键字volatile"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">五、关键字volatile</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#1-volatile关键字的使用"><span class="toc_mobile_items-number">5.1.</span> <span class="toc_mobile_items-text">1. volatile关键字的使用</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#2-volatile与synchronized的区别"><span class="toc_mobile_items-number">5.2.</span> <span class="toc_mobile_items-text">2. volatile与synchronized的区别</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-1-原子性"><span class="toc_mobile_items-number">5.2.1.</span> <span class="toc_mobile_items-text">2.1 原子性</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-2-原子变量"><span class="toc_mobile_items-number">5.2.2.</span> <span class="toc_mobile_items-text">2.2 原子变量</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-3-原子变量实现原理（CAS算法）"><span class="toc_mobile_items-number">5.2.3.</span> <span class="toc_mobile_items-text">2.3 原子变量实现原理（CAS算法）</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一、Java创建线程的四种方式"><span class="toc-number">1.</span> <span class="toc-text">一、Java创建线程的四种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-继承Thread类实现多线程"><span class="toc-number">1.1.</span> <span class="toc-text">1. 继承Thread类实现多线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-实现Runnable接口实现多线程"><span class="toc-number">1.2.</span> <span class="toc-text">2. 实现Runnable接口实现多线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-实现Callable接口实现多线程（jdk1-5以后）"><span class="toc-number">1.3.</span> <span class="toc-text">3. 实现Callable接口实现多线程（jdk1.5以后）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-创建线程池"><span class="toc-number">1.4.</span> <span class="toc-text">4. 创建线程池</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#二、Thread类详解"><span class="toc-number">2.</span> <span class="toc-text">二、Thread类详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-构造方法"><span class="toc-number">2.1.</span> <span class="toc-text">1. 构造方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-Thread"><span class="toc-number">2.1.1.</span> <span class="toc-text">1.1 Thread()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Thread-Runnable-target"><span class="toc-number">2.1.2.</span> <span class="toc-text">1.2 Thread(Runnable target)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-Thread-Runnable-target-String-name"><span class="toc-number">2.1.3.</span> <span class="toc-text">1.3 Thread(Runnable target, String name)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-static-Thread-currentThread"><span class="toc-number">2.2.</span> <span class="toc-text">2. static Thread currentThread()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-获取线程信息"><span class="toc-number">2.3.</span> <span class="toc-text">3. 获取线程信息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-public-long-getId"><span class="toc-number">2.3.1.</span> <span class="toc-text">3.1 public long getId()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-public-String-getName"><span class="toc-number">2.3.2.</span> <span class="toc-text">3.2 public String getName()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-public-int-getStackTrace"><span class="toc-number">2.3.3.</span> <span class="toc-text">3.3 public int getStackTrace()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-public-boolean-isDaemon"><span class="toc-number">2.3.4.</span> <span class="toc-text">3.4 public boolean isDaemon()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-线程控制"><span class="toc-number">2.4.</span> <span class="toc-text">4. 线程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-public-void-start"><span class="toc-number">2.4.1.</span> <span class="toc-text">4.1 public void start()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-public-void-join-public-void-join-long-millis"><span class="toc-number">2.4.2.</span> <span class="toc-text">4.2 public void join()&#x2F;public void join(long millis)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-public-static-void-sleep-long-millis"><span class="toc-number">2.4.3.</span> <span class="toc-text">4.3 public static void sleep(long millis)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-其他控制线程的方法"><span class="toc-number">2.4.4.</span> <span class="toc-text">4.4 其他控制线程的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-wait-Object-wait-long-timeout"><span class="toc-number">2.4.4.1.</span> <span class="toc-text">Object.wait()&#x2F;Object.wait(long timeout)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-notify-Object-notifyAll"><span class="toc-number">2.4.4.2.</span> <span class="toc-text">Object.notify()&#x2F;Object.notifyAll()</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#三、同步（并发）问题"><span class="toc-number">3.</span> <span class="toc-text">三、同步（并发）问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-产生同步问题的案例"><span class="toc-number">3.1.</span> <span class="toc-text">1. 产生同步问题的案例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-解决多线程同步问题-synchronized"><span class="toc-number">3.2.</span> <span class="toc-text">2. 解决多线程同步问题-synchronized</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-解决多线程同步问题-java-util-concurrent-Lock"><span class="toc-number">3.3.</span> <span class="toc-text">3. 解决多线程同步问题-java.util.concurrent.Lock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-剖析产生并发问题的原因"><span class="toc-number">3.4.</span> <span class="toc-text">4. 剖析产生并发问题的原因</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#四、锁"><span class="toc-number">4.</span> <span class="toc-text">四、锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-什么是锁"><span class="toc-number">4.1.</span> <span class="toc-text">1. 什么是锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-理解synchronized关键字"><span class="toc-number">4.2.</span> <span class="toc-text">2. 理解synchronized关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-显示锁java-util-concurrent-Lock"><span class="toc-number">4.3.</span> <span class="toc-text">3. 显示锁java.util.concurrent.Lock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-java-concurrent-locks-Condition类"><span class="toc-number">4.3.1.</span> <span class="toc-text">3.1 java.concurrent.locks.Condition类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#五、关键字volatile"><span class="toc-number">5.</span> <span class="toc-text">五、关键字volatile</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-volatile关键字的使用"><span class="toc-number">5.1.</span> <span class="toc-text">1. volatile关键字的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-volatile与synchronized的区别"><span class="toc-number">5.2.</span> <span class="toc-text">2. volatile与synchronized的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-原子性"><span class="toc-number">5.2.1.</span> <span class="toc-text">2.1 原子性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-原子变量"><span class="toc-number">5.2.2.</span> <span class="toc-text">2.2 原子变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-原子变量实现原理（CAS算法）"><span class="toc-number">5.2.3.</span> <span class="toc-text">2.3 原子变量实现原理（CAS算法）</span></a></li></ol></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(/assets/1575087573085.png)"><div id="post-info"><div id="post-title"><div class="posttitle">Java并发知识点整理（1）</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2019-10-18<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2021-06-29</time><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span><span class="post-meta__separator">|</span><i class="fa fa-comments-o post-meta__icon fa-fw" aria-hidden="true"></i><span>评论数:</span><a href="/2019/10/18/Java%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/#post-comment"><span class="gitalk-comment-count comment-count"></span></a></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><html><head></head><body><p><a href="/assets/jva.jpg" data-fancybox="group" data-caption class="fancybox"><img alt title data-src="/assets/jva.jpg" class="lazyload"></a></p>
<p>Java多线程知识点整理。</p>
<p>今天才学习完<a href="https://www.bilibili.com/video/av21398578" target="_blank" rel="noopener">尚硅谷Java视频_JUC 视频教程_哔哩哔哩 (゜-゜)つロ 干杯~-bilibili</a>，然后结合自己对于Java多线程的理解，汇总了下面的知识点，这是第一篇，后面还要出一篇。</p>
<p>不过这点Java多线程知识远远不够，后面应该在校招之前还要继续看高并发的东西然后再出几篇博客……</p>
<a id="more"></a>

<h1 id="一、Java创建线程的四种方式"><a href="#一、Java创建线程的四种方式" class="headerlink" title="一、Java创建线程的四种方式"></a>一、Java创建线程的四种方式</h1><p>这里说的是<strong>创建线程</strong>的四种方式，然后很多教材和博客上会说<em>创建线程的方式有三种</em>，其实创建线程池也是创建了线程，只是不执行任务而已。</p>
<h2 id="1-继承Thread类实现多线程"><a href="#1-继承Thread类实现多线程" class="headerlink" title="1. 继承Thread类实现多线程"></a>1. 继承Thread类实现多线程</h2><p>核心方法：<code>public void run()</code></p>
<p>示例代码如下：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i<<span class="number">10</span>;i++){</span><br><span class="line">            <span class="comment">// 输出当前线程名 + 当前的i值</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String...args)</span></span>{</span><br><span class="line">        MyThread t1=<span class="keyword">new</span> MyThread();</span><br><span class="line">        MyThread t2=<span class="keyword">new</span> MyThread();</span><br><span class="line">        MyThread t3=<span class="keyword">new</span> MyThread();</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<h2 id="2-实现Runnable接口实现多线程"><a href="#2-实现Runnable接口实现多线程" class="headerlink" title="2. 实现Runnable接口实现多线程"></a>2. 实现Runnable接口实现多线程</h2><p>核心方法：<code>public void run()</code></p>
<p>示例代码如下：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i<<span class="number">10</span>;i++){</span><br><span class="line">            <span class="comment">// 输出当前线程名 + 当前的i值</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String...args)</span></span>{</span><br><span class="line">      	MyThread t1=<span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="keyword">new</span> Thread(t1).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(t1).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(t1).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<blockquote>
<p><code>java.lang.Thread</code>和<code>java.lang.Runnable</code>的异同：</p>
<ol>
<li>通过查阅JDK文档，我们可以看到，<code>Thread</code>类也实现了<code>Runnable</code>接口</li>
<li><code>Thread</code>类由于Java单继承限制，因此通过继承实现多线程的灵活性较差；而<code>Runnable</code>接口可以让类实现多个接口，比较灵活</li>
<li>在实现<code>Runnable</code>这种方式中，使用了简单的代理模式：<code>MyThread</code>类负责业务操作，而<code>Thread</code>类负责资源调度与线程创建</li>
</ol>
</blockquote>
<h2 id="3-实现Callable接口实现多线程（jdk1-5以后）"><a href="#3-实现Callable接口实现多线程（jdk1-5以后）" class="headerlink" title="3. 实现Callable接口实现多线程（jdk1.5以后）"></a>3. 实现Callable<t>接口实现多线程（jdk1.5以后）</t></h2><p>核心方法：<code>public T call()</code></p>
<p>示例代码如下：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Callable</span><<span class="title">Integer</span>></span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i<<span class="number">10</span>;i++){</span><br><span class="line">            sum+=<span class="keyword">new</span> Randow().nextInt(<span class="number">10</span>);<span class="comment">//随机数之和</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String...args)</span></span>{</span><br><span class="line">        MyThread t1=<span class="keyword">new</span> MyThread();</span><br><span class="line">        FutureTask<integer> task=<span class="keyword">new</span> FutureTask<>(t1);</integer></span><br><span class="line">        <span class="keyword">new</span> Thread(task).start();<span class="comment">// 运行线程</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            System.out.println(result.get());<span class="comment">//打印结果</span></span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        } <span class="keyword">catch</span> (ExecutionException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<blockquote>
<p><code>java.util.concurrent.Callable<t></t></code>接口和<code>java.lang.Runnable</code>接口异同</p>
<ol>
<li>实现了<code>Callable<t></t></code>的对象并不能直接运行，需要以其为参数实现一个<code>java.util.concurrent.FutureTask<v></v></code>对象，然后才可以放到<code>Thread</code>对象里面执行</li>
<li><code>Callable<t></t></code>支持返回值，泛型为返回值类型，并且可以抛出异常</li>
<li>接受的返回值通过<code>FutureTask<v></v></code>对象的<code>get()</code>方法获得</li>
<li><code>FutureTask<v></v></code>可以用于<strong>闭锁</strong></li>
</ol>
</blockquote>
<h2 id="4-创建线程池"><a href="#4-创建线程池" class="headerlink" title="4. 创建线程池"></a>4. 创建线程池</h2><p>线程池负责线程的使用与调度，但不负责线程内部的业务逻辑，因此创建线程池仅仅是创建了线程，如果要执行相应的业务逻辑，还是需要使用上述三种方式创建线程实现的类。</p>
<p>示例代码如下：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> MyThread{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String...args)</span></span>{</span><br><span class="line">        ExecutorService pool = Executors.newFixedThreadPool(<span class="number">2</span>);<span class="comment">//创建一个仅有2个线程的线程池实例</span></span><br><span class="line">        <span class="comment">// 向线程池添加任务</span></span><br><span class="line">        pool.submit(<span class="keyword">new</span> Runnable(){</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>{</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i<<span class="number">10</span>;i++){</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">" : "</span>+i);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        <span class="comment">// 当线程池中的任务都完成后，关闭线程池</span></span><br><span class="line">        pool.shutdown();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<h1 id="二、Thread类详解"><a href="#二、Thread类详解" class="headerlink" title="二、Thread类详解"></a>二、Thread类详解</h1><p>下面来仔细介绍几个<code>Thread</code>类中的重要方法……</p>
<h2 id="1-构造方法"><a href="#1-构造方法" class="headerlink" title="1. 构造方法"></a>1. 构造方法</h2><h3 id="1-1-Thread"><a href="#1-1-Thread" class="headerlink" title="1.1 Thread()"></a>1.1 Thread()</h3><p>构造一个新的Thread对象</p>
<h3 id="1-2-Thread-Runnable-target"><a href="#1-2-Thread-Runnable-target" class="headerlink" title="1.2 Thread(Runnable target)"></a>1.2 Thread(Runnable target)</h3><p>构造一个新的Thread对象，并且将Runnable接口参数作为自己的运营对象。即当执行<code>start()</code>方法后，执行的将是<code>target.run()</code>方法</p>
<h3 id="1-3-Thread-Runnable-target-String-name"><a href="#1-3-Thread-Runnable-target-String-name" class="headerlink" title="1.3 Thread(Runnable target, String name)"></a>1.3 Thread(Runnable target, String name)</h3><p>构造一个新的Thread对象，实现<code>Thread(Runnable target)</code>构造方法，并且将这个新的Thread对象的线程名设置为`name</p>
<h2 id="2-static-Thread-currentThread"><a href="#2-static-Thread-currentThread" class="headerlink" title="2. static Thread currentThread()"></a>2. static Thread currentThread()</h2><p>返回当前正在执行的线程对象的引用。</p>
<p>这个静态方法的作用一般是用于在通过实现<code>Runnable</code>接口或<code>Callable</code>接口的线程类中，需要使用到当前执行的线程对象的引用。例如获取当前执行的线程的线程名就要在<code>run()</code>方法中这么写<code>Thread.currentThread().getName()</code></p>
<h2 id="3-获取线程信息"><a href="#3-获取线程信息" class="headerlink" title="3. 获取线程信息"></a>3. 获取线程信息</h2><h3 id="3-1-public-long-getId"><a href="#3-1-public-long-getId" class="headerlink" title="3.1 public long getId()"></a>3.1 public long getId()</h3><p>获取线程的标识符。这个线程ID是创建线程时候自动生成的唯一ID，在线程销毁后可以复用。</p>
<h3 id="3-2-public-String-getName"><a href="#3-2-public-String-getName" class="headerlink" title="3.2 public String getName()"></a>3.2 public String getName()</h3><p>获取线程名。线程名可以通过程序自动生成，也可以通过构造方法来指定线程名，还可以通过<code>serName(String name)</code>来设置线程名</p>
<h3 id="3-3-public-int-getStackTrace"><a href="#3-3-public-int-getStackTrace" class="headerlink" title="3.3 public int getStackTrace()"></a>3.3 public int getStackTrace()</h3><p>获取线程的优先级。线程优先级可以通过<code>setPriority(int newPriority)</code>来设置优先级（一般为0到10）</p>
<p>线程优先级越高，该线程越可能被分配到CPU资源。</p>
<h3 id="3-4-public-boolean-isDaemon"><a href="#3-4-public-boolean-isDaemon" class="headerlink" title="3.4 public boolean isDaemon()"></a>3.4 public boolean isDaemon()</h3><p>获取这个线程是否为守护线程。可以通过<code>setDaemon(boolean on)</code>方法来设置该线程是否为守护线程。</p>
<h2 id="4-线程控制"><a href="#4-线程控制" class="headerlink" title="4. 线程控制"></a>4. 线程控制</h2><h3 id="4-1-public-void-start"><a href="#4-1-public-void-start" class="headerlink" title="4.1 public void start()"></a>4.1 public void start()</h3><p>开始执行线程，Java虚拟机开始调用此线程的<code>public void run()</code>方法</p>
<h3 id="4-2-public-void-join-public-void-join-long-millis"><a href="#4-2-public-void-join-public-void-join-long-millis" class="headerlink" title="4.2 public void join()/public void join(long millis)"></a>4.2 public void join()/public void join(long millis)</h3><p>将该线程加入到主线程，等待最多millis毫秒的时间（默认为无穷），当主线程执行到<code>join()</code>方法时，主线程会挂起，只有当超时或该线程完成操作后，主线程才会继续往下执行。</p>
<p>下面是个例子，通过例子自行体会其中的奥秘：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJoin</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String...args)</span></span>{</span><br><span class="line">        Thread td=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<<span class="number">10</span>;i++){</span><br><span class="line">                    System.out.println(i);</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        td.start();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            td.join(<span class="number">200</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Thread.sleep(<span class="number">300</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"--------"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<h3 id="4-3-public-static-void-sleep-long-millis"><a href="#4-3-public-static-void-sleep-long-millis" class="headerlink" title="4.3 public static void sleep(long millis)"></a>4.3 public static void sleep(long millis)</h3><p>是当前正在执行的线程停留millis毫秒的时间。</p>
<h3 id="4-4-其他控制线程的方法"><a href="#4-4-其他控制线程的方法" class="headerlink" title="4.4 其他控制线程的方法"></a>4.4 其他控制线程的方法</h3><h4 id="Object-wait-Object-wait-long-timeout"><a href="#Object-wait-Object-wait-long-timeout" class="headerlink" title="Object.wait()/Object.wait(long timeout)"></a><code>Object.wait()</code>/<code>Object.wait(long timeout)</code></h4><p>可以看到，这是Object内置的一个方法，该方法可以导致当前线程等待，直到超时（默认为无穷）或另一个线程调用<code>Object.notify()</code>方法或<code>Object.notifyAll()</code>方法。</p>
<h4 id="Object-notify-Object-notifyAll"><a href="#Object-notify-Object-notifyAll" class="headerlink" title="Object.notify()/Object.notifyAll()"></a><code>Object.notify()</code>/<code>Object.notifyAll()</code></h4><p>唤醒当前对象或唤醒全部对象。这两个方法可以配合上面<code>Object.wait()</code>方法来解决同步问题（又叫<strong>等待-唤醒</strong>机制）。</p>
<p>例：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Clerk</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> product = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进货</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> (product >= <span class="number">1</span>) {</span><br><span class="line">            System.out.println(<span class="string">"产品已满，无法添加"</span>);</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + ++product);</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//卖货</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">while</span> (product <= <span class="number">0</span>) {</span><br><span class="line">            System.out.println(<span class="string">"缺货！"</span>);</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + --product);</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<h1 id="三、同步（并发）问题"><a href="#三、同步（并发）问题" class="headerlink" title="三、同步（并发）问题"></a>三、同步（并发）问题</h1><p>多线程的同步问题指的是多个线程同时修改一个数据的时候，可能导致的问题</p>
<h2 id="1-产生同步问题的案例"><a href="#1-产生同步问题的案例" class="headerlink" title="1. 产生同步问题的案例"></a>1. 产生同步问题的案例</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrencyTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cont = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">5000</span>; i++) {</span><br><span class="line">            cont += <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCont</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(cont);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] agrs)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        ConcurrencyTest c1 = <span class="keyword">new</span> ConcurrencyTest();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(c1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(c1);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">// 让主线程等待子线程完成</span></span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        c1.getCont();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p>上面这个案例逻辑很简单，就是让程序开辟两个线程同时对<code>cont</code>进行+1操作5000次，我们预期的结果应该是<strong>10000</strong>，但是多运行几次我们会发现，结果并不像我们预期的那样，而总是一个小于等于10000的数，而这个数我们一般称为<strong>脏数据</strong>。</p>
<p>上面这个就是一个典型的多线程同步问题。</p>
<h2 id="2-解决多线程同步问题-synchronized"><a href="#2-解决多线程同步问题-synchronized" class="headerlink" title="2. 解决多线程同步问题-synchronized"></a>2. 解决多线程同步问题-<code>synchronized</code></h2><p>对于<code>synchronized</code>关键字的解释将在[四、2.  理解<code>synchronized</code>关键字](##2. 理解<code>synchronized</code>关键字)说明，这里仅仅先展示其用法。</p>
<p>代码修改如下：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrencyTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cont = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 第一种方式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) { <span class="comment">// 这里为对象添加了synchronized关键字</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">5000</span>; i++) {</span><br><span class="line">                cont += <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 第二种方式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{ <span class="comment">// 这里为对象修饰符处添加了synchronized关键字</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">5000</span>; i++) {</span><br><span class="line">            cont += <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCont</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(cont);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] agrs)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        ConcurrencyTest c1 = <span class="keyword">new</span> ConcurrencyTest();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(c1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(c1);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">// 让主线程等待子线程完成</span></span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        c1.getCont();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p>这个改进的案例展示了<code>synchronized</code>关键字的两种使用方式：</p>
<ul>
<li>使用在代码块处，括号中的参数为需要同步的<strong>对象</strong>，案例中需要同步的对象是其本身，因此是<code>synchronized(this)</code></li>
<li>使用在方法声明处，与访问修饰符、静态修饰符同级，表示对该方法进行同步</li>
</ul>
<h2 id="3-解决多线程同步问题-java-util-concurrent-Lock"><a href="#3-解决多线程同步问题-java-util-concurrent-Lock" class="headerlink" title="3. 解决多线程同步问题-java.util.concurrent.Lock"></a>3. 解决多线程同步问题-<code>java.util.concurrent.Lock</code></h2><p>对于<code>java.util.concurrent.Lock</code>的解释将在[四、3. 显示锁<code>java.util.concurrent.Lock</code>](##3. 显示锁<code>java.util.concurrent.Lock</code>)进行解释，这里仅仅展示它的使用方法。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrencyTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> cont = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock=<span class="keyword">new</span> ReentrantLock(); <span class="comment">// 获取锁</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        lock.lock();<span class="comment">// 加锁</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">5000</span>; i++) {</span><br><span class="line">            cont += <span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">        lock.unlock();<span class="comment">// 释放锁</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCont</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(cont);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] agrs)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        ConcurrencyTest c1 = <span class="keyword">new</span> ConcurrencyTest();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(c1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(c1);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">// 让主线程等待子线程完成</span></span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        c1.getCont();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p>这段代码和使用<code>synchronized</code>的代码最终效果是一样的，都可以输出<code>10000</code>，然后<code>Lock</code>显示锁的一般使用方法就是这样子的，但是要注意，一定要执行<code>unlock()</code>方法，否则对象会一直持有锁，导致程序阻塞。</p>
<h2 id="4-剖析产生并发问题的原因"><a href="#4-剖析产生并发问题的原因" class="headerlink" title="4. 剖析产生并发问题的原因"></a>4. 剖析产生并发问题的原因</h2><p>首先我们先理解一个概念叫<strong>内存可见性</strong>：当多个线程操作共享数据时候，彼此不可见</p>
<p>大概意思就是在多线程项目中，我们的内存可以简单的理解为<strong>主存</strong>和<strong>线程缓存</strong>，而线程的所有操作都是先从主存中获取变量的当前值，然后在自己的线程缓存中进行的，如下图：</p>
<p><a href="/assets/1571452781443.png" data-fancybox="group" data-caption="1571452781443" class="fancybox"><img alt="1571452781443" title="1571452781443" data-src="/assets/1571452781443.png" class="lazyload"></a></p>
<p>在案例中，线程1和线程2每次执行运算操作都要先从主存中获取当前的x，然后再对x做一个+1操作，然后把结果返回给主存；但是由于线程是<strong>并行</strong>执行的，因此很可能出现线程1还没有将自己的运算结果返回给主存，然后线程2就读取了主存中的x值，这样一来，线程2就相当于做了一次重复的运算，并且这个结果还会返回给主存导致后面的运算全部出错……由此，产生了脏数据。</p>
<h1 id="四、锁"><a href="#四、锁" class="headerlink" title="四、锁"></a>四、锁</h1><h2 id="1-什么是锁"><a href="#1-什么是锁" class="headerlink" title="1. 什么是锁"></a>1. 什么是锁</h2><p>在Java多线程编程中，锁可以理解为对象拥有的一种资源或标志。通常情况下，持有锁的对象只能有一个线程对齐进行操作，而其他线程尝试访问的时候会被阻止。</p>
<p>对比上面的剖析，我们可以认为，每次某个线程需要操作数据的时候，一定会确认其他线程已经完成了对这个数据的操作，并且成功的返回到了主存中，此时该线程才会从主存中读取数据然后进行计算。</p>
<p>Java中的锁大概有两类：</p>
<ul>
<li><code>synchronized</code>关键字</li>
<li><code>java.util.concurrent</code>包下面的锁</li>
</ul>
<h2 id="2-理解synchronized关键字"><a href="#2-理解synchronized关键字" class="headerlink" title="2. 理解synchronized关键字"></a>2. 理解<code>synchronized</code>关键字</h2><p>这里参考了<em>《Java编程思想》p677</em></p>
<blockquote>
<p>当任务要执行被<code>synchronized</code>关键字保护的代码片段的时候，它将检查锁是否可用，然后获得锁，执行代码，释放锁。</p>
<p>所有对象都自动含有单一的锁（也称为监视器）。当在对象上调用包含<code>synchronized</code>关键字的方法的时候，该对象会被加锁，这个时候该对象上的其他被<code>synchronized</code>关键字修饰的方法需要等待上一个方法执行完毕并释放锁后才可以被执行。</p>
</blockquote>
<p>上面第一段说的是锁的作用；第二段表名锁是针对整个对象而言的，而不是针对某一个方法而言的。</p>
<p>示例代码如下所示：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrencyTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcurrencyTest</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (b){</span><br><span class="line">            getA();</span><br><span class="line">        }<span class="keyword">else</span> {</span><br><span class="line">            getB();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">getA</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<<span class="number">50</span>;i++){</span><br><span class="line">            System.out.print(<span class="string">'a'</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">getB</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i<<span class="number">50</span>;i++){</span><br><span class="line">            System.out.print(<span class="string">'b'</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] agrs)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        ConcurrencyTest c1 = <span class="keyword">new</span> ConcurrencyTest(<span class="keyword">true</span>);</span><br><span class="line">        ConcurrencyTest c2 = <span class="keyword">new</span> ConcurrencyTest(<span class="keyword">false</span>);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(c1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(c2);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">// 让主线程等待子线程完成</span></span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        System.out.println();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p>对于上面的代码中的<code>getA()</code>和<code>getB()</code>方法有如下三种情况：</p>
<ul>
<li>两个方法同时没有添加<code>synchronized</code>关键字，输出的a和b是乱序的，证明在执行任意方法的时候，另一个方法可以同时执行</li>
<li>两个方法同时添加<code>synchronized</code>关键字，输出的是整齐的字符串，证明在执行任一方法的时候，另一个方法都必须等待上一个方法执行完才可以执行</li>
<li>其中一个方法添加<code>synchronized</code>关键字，被修饰的方法输出的是整齐的字符串，但是其开头和结尾会插入另一个方法的字符，这个情况就可以证明前面说的第二段内容</li>
</ul>
<p>刚才所说，<code>synchronized</code>是给对象加锁，那么修饰方法的<code>synchronized</code>关键字就可以理解为下面这一段代码：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="keyword">this</span>){</span><br><span class="line">    <span class="comment">// 方法代码</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p>有时候，方法会被<code>static</code>修饰，如果一个方法同时被<code>static synchronized</code>两个关键字修饰，那么这个方法就被称为<strong>静态同步方法</strong>，此时，<code>synchronized</code>关键字就不是给<code>this</code>加锁了，而是给这个类的<code>Class</code>对象加锁，类似于下面的代码：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(Object<span class="class">.<span class="keyword">class</span>)</span>{</span><br><span class="line">    <span class="comment">// 方法代码</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<h2 id="3-显示锁java-util-concurrent-Lock"><a href="#3-显示锁java-util-concurrent-Lock" class="headerlink" title="3. 显示锁java.util.concurrent.Lock"></a>3. 显示锁<code>java.util.concurrent.Lock</code></h2><p>显示锁对应的是隐式锁，隐式锁就是通过<code>synchronized</code>修饰的方法或者对象，其为对象加的锁我们成为<strong>隐式锁</strong>，而使用<code>java.util.concurrent.Lock</code>对象来给对象加锁，我们称为<strong>显示锁</strong>。</p>
<p><code>Lock</code>是一个接口，其接口中定义了一下几个方法：</p>
<ul>
<li><code>void lock()</code>获得锁</li>
<li><code>Condition newCondition()</code>返回一个新的Condition绑定到Lock实例，对于Condition下面会进行讲解</li>
<li><code>boolean tryLock()</code>如果锁没有被其他线程占有的时候，则该方法返回<code>true</code>且和<code>lock()</code>方法作用相同，如果锁被其他线程占有，则返回<code>false</code>，然后不再等待释放锁，而是直接跳过执行；一般要和if…else…配合使用</li>
<li><code>void unLock()</code>释放锁</li>
</ul>
<p>使用显示锁的一大好处就是<strong>更加灵活</strong>，在使用的时候，只要在需要加锁的代码段前面使用<code>lock()</code>方法获取锁，然后在需要加锁的代码段后面使用<code>unlock()</code>释放锁即可，而<code>synchorinzed</code>关键字只能用在一个 代码块或者一个方法上，相比之下灵活性较弱。</p>
<p>使用<code>Lock</code>的方式很简单，只需要在类中定义一个<code>Lock</code>对象即可：<code>Lock lock=new ReentranLock()</code>，然后根据上面的描述使用<code>lock</code>对象即可。</p>
<h3 id="3-1-java-concurrent-locks-Condition类"><a href="#3-1-java-concurrent-locks-Condition类" class="headerlink" title="3.1 java.concurrent.locks.Condition类"></a>3.1 <code>java.concurrent.locks.Condition</code>类</h3><p>上面所讲，我们可以通过Lock对象的<code>newCondition()</code>方法得到一个新的<code>Condition</code>对象绑定到<code>Lock</code>对象。</p>
<p>这个<code>Condition</code>是什么呢？这个类大概就是实现了对于Lock接口的<code>Object.wait()</code>方法和<code>Object.notify()/Object.notifyAll()</code>方法。他有如下几个重要的方法：</p>
<ul>
<li><code>public void awite()</code> 导致当前线程暂停，类似于<code>Object.wait()</code>方法</li>
<li><code>public void signal()</code> 唤醒当前线程，类似于<code>Object.notify()</code>方法</li>
<li><code>public void signalAll()</code> 唤醒所有线程，类似于<code>Object.notifyAll()</code>方法</li>
</ul>
<h1 id="五、关键字volatile"><a href="#五、关键字volatile" class="headerlink" title="五、关键字volatile"></a>五、关键字<code>volatile</code></h1><h2 id="1-volatile关键字的使用"><a href="#1-volatile关键字的使用" class="headerlink" title="1. volatile关键字的使用"></a>1. <code>volatile</code>关键字的使用</h2><p>在了解<code>volatile</code>关键字之前，我们先看一下下面这个例子：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVolatile</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span> </span>{</span><br><span class="line">        ThreadDemo td = <span class="keyword">new</span> ThreadDemo();</span><br><span class="line">        <span class="keyword">new</span> Thread(td).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">            <span class="keyword">if</span> (td.isFlag()) {</span><br><span class="line">                System.out.println(<span class="string">"--------------"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">        System.out.println(<span class="string">"flag = "</span> + isFlag());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFlag</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p>上面这个程序，我们预计的输出应该是</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flag = true</span><br><span class="line">--------------</span><br></pre></td></tr></tbody></table></figure></div>

<p>但是，我们将这段代码放到编译器中执行，发现程序只输出<code>flag = true</code>，然后主线程就<strong>阻塞</strong>了……</p>
<p>这是为什么呢？我们来分析一下上面案例中的代码：</p>
<blockquote>
<ol>
<li>程序一共有两个线程：主线程和子线程</li>
<li>子线程中有修改<code>flag</code>的操作，即写入数据；而主线程中有读取`flag的操作，即读取数据</li>
<li>子线程中延迟了0.2s然后才对flag进行修改</li>
<li>主线程中读取<code>flag</code>的操作卸载了<code>while(true)</code>中，即死循环中，除非<code>flag</code>为真才停止</li>
</ol>
</blockquote>
<p>然后我们利用前面第三节<strong>剖析产生并发问题的原因</strong>中所介绍的，主线程也是线程，主线程读取数据也应该从主存中进行读取，然后再进行操作。不过呢，由于while的执行效率极其之高，导致主线程中的死循环代码无法读取到更新后的<code>flag</code>值（可以通过在while(true)里面添加一个1ms的延迟来观看效果）。</p>
<p>至于解决办法，确实可以使用我们上面的<code>synchronized</code>关键字或<code>Lock</code>锁使操作同步，但是这里我们换一种实现方式：使用<code>volatile</code>关键字修饰变量。</p>
<p>解决方式为：将上面第19行代码，即声明<code>flag</code>处的代码改为：<code>private volatile boolean flag = false</code></p>
<p>添加了<code>volatile</code>关键字修饰后的<code>flag</code>变量，对其的写操作会比对其的读操作先发生<em>参考《深入理解Java虚拟机》p376</em>，由于此案例两个线程分别包含了对<code>flag</code>的读操作和写操作，那么对于<code>volatile</code>的规则则是允许的。</p>
<h2 id="2-volatile与synchronized的区别"><a href="#2-volatile与synchronized的区别" class="headerlink" title="2. volatile与synchronized的区别"></a>2. <code>volatile</code>与<code>synchronized</code>的区别</h2><ul>
<li><code>volatile</code>是一种较为轻量级的<strong>同步策略</strong>，它提供的是一种<strong>非阻塞同步</strong>，而<code>synchronized</code>以及锁都是一种<strong>阻塞同步</strong></li>
<li><code>volatile</code>不具备“互斥性”（互斥性：当一个线程占有锁的时候，其他线程不可以访问锁住的数据）</li>
<li><code>volatile</code>不能保证变量的“原子性”</li>
</ul>
<p>前两点我们可以通过上面的案例很好理解。首先，阻塞同步的性能在于处理器进行线程阻塞或唤醒线程带来的性能问题，而<code>volatile</code>并不会对线程进行阻塞或唤醒（或者说是需要的时候再进行这些操作）；其次，“互斥性”等同于“互斥同步”或“阻塞同步”，所以<code>volatile</code>不具备“互斥性”</p>
<p>下面我们着重对第三点进行讲解。</p>
<h3 id="2-1-原子性"><a href="#2-1-原子性" class="headerlink" title="2.1 原子性"></a>2.1 原子性</h3><p>首先再看个案例：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrencyTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cont = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">5000</span>; i++) {</span><br><span class="line">            cont ++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCont</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(cont);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] agrs)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        ConcurrencyTest c1 = <span class="keyword">new</span> ConcurrencyTest();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(c1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(c1);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">// 让主线程等待子线程完成</span></span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        c1.getCont();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p>这个案例就是之前的产生同步问题的案例，不过我们为那个共享的变量添加了一个刚刚学习的<code>volatile</code>关键字，但是我们运行之后并不能得到我们期待的结果10000。</p>
<p>由此，我们引出了<strong>原子性</strong>问题：</p>
<blockquote>
<p><strong>i++ 原子性问题</strong>：i++的操作实际上分为三步，即<strong>读-改-写</strong>，翻译成代码如下：<code>int temp=i;i=temp+1;return i;</code>。因为i++的操作分成了三个步骤，且中间有个临时变量生成，因此我们不能只使用<code>volatile</code>修饰变量来保证i++的正常执行。</p>
</blockquote>
<h3 id="2-2-原子变量"><a href="#2-2-原子变量" class="headerlink" title="2.2 原子变量"></a>2.2 原子变量</h3><p>jdk1.5以后，java.util.concurrent.atomic包下提供了大量<strong>原子变量</strong>，这些原子变量就是专门为了解决原子性问题的。</p>
<p>首先我们来看看原子变量都有哪些：</p>
<p><code>AtomicBoolean</code><br><code>AtomicInteger</code><br><code>AtomicLong</code><br><code>AtomicReference</code><br><code>AtomicLongArray</code><br><code>AtomicReferenceArray</code><br><code>AtomicIntegerFieldUpdater</code><br><code>AtomicReferenceFieldUpdater</code><br><code>LongAdder</code><br><code>LongAccumulator</code><br><code>DoubleAdder</code><br><code>DoubleAccumulator</code></p>
<p>这些原子变量几乎包含了所有我们在实际开发中要使用到的变量类型。</p>
<p>然后是这些原子变量的使用：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrencyTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> AtomicInteger cont = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">5000</span>; i++) {</span><br><span class="line">            cont.getAndIncrement();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getCont</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(cont);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] agrs)</span> <span class="keyword">throws</span> InterruptedException </span>{</span><br><span class="line">        ConcurrencyTest c1 = <span class="keyword">new</span> ConcurrencyTest();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(c1);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(c1);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        <span class="comment">// 让主线程等待子线程完成</span></span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line">        c1.getCont();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

<p>对于这些原子变量的使用，我们可以参考jdk文档。</p>
<h3 id="2-3-原子变量实现原理（CAS算法）"><a href="#2-3-原子变量实现原理（CAS算法）" class="headerlink" title="2.3 原子变量实现原理（CAS算法）"></a>2.3 原子变量实现原理（CAS算法）</h3><p>原子变量的实现原理主要是<strong>CAS（Compare-And-Swap）</strong>算法。下面就来说说到底什么是CAS算法</p>
<blockquote>
<p>CAS定义了三个操作数：1. 内存值<strong>V</strong>  2. 预估值<strong>B</strong>  3. 更新值<strong>A</strong></p>
<p>在执行更新操作的时候，<strong>当且仅当V==A时，才会使得V==B，否则不进行任何操作</strong>，但是无论是否更新了V的值，都会返回V的旧值</p>
</blockquote>
<p>这个CAS算法的简单实现我们可以参考下面的代码：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand code-closed" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompareAndSwap</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取内存值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">compareAndSwap</span><span class="params">(<span class="keyword">int</span> expectedValue, <span class="keyword">int</span> newVale)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> oldValue = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (oldValue == expectedValue) {</span><br><span class="line">            <span class="keyword">this</span>.value = newVale;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expectedValue, <span class="keyword">int</span> newValue)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> expectedValue == compareAndSwap(expectedValue, newValue);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div>

</body></html></div></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java    </a><a class="post-meta__tags" href="/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/">高并发    </a></div><div class="post_share"><div class="social-share" data-image="/assets/1575087573085.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.png" alt="微信"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2019/11/01/IntelliJ-IDEA-%E6%89%93%E9%80%A0%E6%9C%80%E5%BC%BA%E5%A4%A7%E7%9A%84Java-IDE/"><img class="prev_cover lazyload" data-src="/assets/intellij-idea_1280x800.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>IntelliJ IDEA--打造最强大的Java-IDE</span></div></a></div><div class="next-post pull_right"><a href="/2019/10/17/%E5%B8%B8%E7%94%A8%E7%AE%80%E5%8D%95sql%E8%AF%AD%E5%8F%A5-%E5%85%A5%E9%97%A8%E7%94%A8/"><img class="next_cover lazyload" data-src="/assets/ac6eddc451da81cb037c289d5366d016082431c3.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>常用简单sql语句(入门用)</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/04/03/Java多线程编程/" title="Java多线程编程"><img class="relatedPosts_cover lazyload"data-src="/assets/1575087573085.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-04-03</div><div class="relatedPosts_title">Java多线程编程</div></div></a></div><div class="relatedPosts_item"><a href="/2019/11/01/IntelliJ-IDEA-打造最强大的Java-IDE/" title="IntelliJ IDEA--打造最强大的Java-IDE"><img class="relatedPosts_cover lazyload"data-src="/assets/intellij-idea_1280x800.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-11-01</div><div class="relatedPosts_title">IntelliJ IDEA--打造最强大的Java-IDE</div></div></a></div><div class="relatedPosts_item"><a href="/2019/04/03/Java玄学之类反射机制/" title="Java玄学之类反射机制"><img class="relatedPosts_cover lazyload"data-src="/assets/1575087573085.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-04-03</div><div class="relatedPosts_title">Java玄学之类反射机制</div></div></a></div><div class="relatedPosts_item"><a href="/2019/04/03/Spring-Boot-No-identifier-specified-for-entity报错解决办法/" title="Spring Boot: No identifier specified for entity报错解决办法"><img class="relatedPosts_cover lazyload"data-src="/assets/u=2656353677,2997395625&fm=26&gp=0.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-04-03</div><div class="relatedPosts_title">Spring Boot: No identifier specified for entity报错解决办法</div></div></a></div><div class="relatedPosts_item"><a href="/2019/04/13/eclipse-小技巧/" title="eclipse 小技巧"><img class="relatedPosts_cover lazyload"data-src="http://img4.imgtn.bdimg.com/it/u=1376956266,2651901568&fm=26&gp=0.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-04-13</div><div class="relatedPosts_title">eclipse 小技巧</div></div></a></div><div class="relatedPosts_item"><a href="/2019/04/03/instanceof运算符/" title="instanceof运算符"><img class="relatedPosts_cover lazyload"data-src="/assets/1575087573085.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-04-03</div><div class="relatedPosts_title">instanceof运算符</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '29b42fd6892324c6f96e',
  clientSecret: '5057141e64d6998667ed7475126857372b8285b6',
  repo: 'pangyuworld.github.io',
  owner: 'pangyuworld',
  admin: 'pangyuworld',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN',
  updateCountCallback: commentCount
})
gitalk.render('gitalk-container')

function commentCount(n){
  document.getElementsByClassName('gitalk-comment-count')[0].innerHTML= n
}</script></div></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By 小胖儿</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://xiaopangemm.coding.me/" target="_blank" rel="noopener">blog</a>!</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":250,"height":500},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>