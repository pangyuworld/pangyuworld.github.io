---
title: 腾讯9.6笔试瞎蒙AC的代码
author: 小胖儿
mathjax: true
date: 2020-09-07 06:50:09
cover:
tags:
	- 秋招
	- 笔试
	- 算法腾讯
---

# 第一题

## 题目

链表的公共部分，给了两个有序递减链表，找出他们的共同节点就行

## 题解

最后只过了50，先不放代码了，后面找到自己代码的问题在放上来，思路很简单，就是两个链表找公共部分，而且还是有序链表，快慢指针就行了

# 第二题

## 题目

通知传递，n个人（序号0~n），m个小组，每个小组有k个人，1个人也能在不同的小组。由0发起的一个通知，每个人都能把通知告诉自己同组的人，求最后收到通知的人数。

## 题解

思路：用一个`HashMap<Integer, Set<Integer>> map = new HashMap<>();`保存下每个人能够影响的范围，建立图，然后对图进行一次遍历就好了，这道题AC了

```java
package com.tencent.x2020q.q2;

import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        HashMap<Integer, Set<Integer>> map = new HashMap<>();
        for (int i = 0; i < m; i++) {
            int l = sc.nextInt();
            Set<Integer> set = new HashSet<>(l);
            for (int j = 0; j < l; j++) {
                set.add(sc.nextInt());
            }
            for (Integer integer : set) {
                Set<Integer> set1 = map.get(integer);
                if (set1 == null || set1.isEmpty()) {
                    map.put(integer, set);
                    continue;
                }
                set1.addAll(set);
                map.put(integer, set1);
            }
        }
        Queue<Integer> queue = new LinkedList<>();
        Set<Integer> result = new HashSet<>();
        queue.addAll(map.get(0));
        while (!queue.isEmpty()){
            Integer i = queue.poll();
            Set<Integer> set = map.get(i);
            for (Integer j : set) {
                if (!result.contains(j)){
                    queue.add(j);
                    result.add(j);
                }
            }
        }
        System.out.println(result.size());
    }
}
```

# 第三题

## 题目

输入N个字符串（有重复），输出这N个字符串中出现次数最多的前K个及出现次数最少的前K个和他们的出现的次数，注意出现次数一样的时候都要进行字典排序

## 题解

取巧办法，首先用`Map<String, Integer> map = new HashMap<>();`保存下每个字符串及其出现的次数，然后我是自定义了一个类保存字符串以及出现次数，把map的数据保存到`List<Word>`中，最后用自定义排序器对链表排序输出即可。因为要输出前K大和前K小，所以我这里为了方便排了两次序

AC代码

```java
package com.tencent.x2020q.q3;


import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int K = sc.nextInt();
        Map<String, Integer> map = new HashMap<>();
        for (int i = 0; i < N; i++) {
            String str = sc.next();
            Integer rank = map.get(str);
            if (rank == null || rank == 0) {
                map.put(str, 1);
            } else {
                map.put(str, rank + 1);
            }
        }
        List<Word> words = new LinkedList<>();
        for (Map.Entry<String, Integer> stringIntegerEntry : map.entrySet()) {
            words.add(new Word(stringIntegerEntry.getKey(), stringIntegerEntry.getValue()));
        }
        Collections.sort(words, (o1, o2) -> {
            if (o1.rank < o2.rank) return 1;
            if (o1.rank > o2.rank) return -1;
            return o1.str.compareTo(o2.str);
        });
        for (int i = 0; i < K; i++) {
            Word word = words.get(i);
            System.out.println(word.str + " " + word.rank);
        }
        Collections.sort(words, (o1, o2) -> {
            if (o1.rank > o2.rank) return 1;
            if (o1.rank < o2.rank) return -1;
            return o1.str.compareTo(o2.str);
        });
        for (int i = 0; i < K; i++) {
            Word word = words.get(i);
            System.out.println(word.str + " " + word.rank);
        }
    }

}

class Word {
    String str;
    int rank = 0;

    public Word(String str, int rank) {
        this.str = str;
        this.rank = rank;
    }
}
```

# 第四题

## 题目

给定一个无序长度为偶数的数组，输出当去掉下标为i的时候，新的数组的中位数

## 题解

第四题大部分人都是因为没有看清题目（也怪开始腾讯没说明白），导致代码写错，其实只要知道了输入的数组不是顺序的，这道题就很好解答了，下面是AC代码

```java
package com.tencent.x2020q.q4;

import java.util.Arrays;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] a = new int[n];
        for (int i = 0; i < a.length; i++) {
            a[i] = sc.nextInt();
        }
        if (n == 2) {
            System.out.println(a[0]);
        }
        int[] t = Arrays.copyOf(a, n);
        Arrays.sort(t);
        int la = t[n / 2 - 1];
        int ra = t[n / 2];
        for (int i = 0; i < n; i++) {
            if (a[i] <= la) {
                System.out.println(ra);
            } else {
                System.out.println(la);
            }
        }
    }
}
```

# 第五题

看了一眼题目，不是我能做出来的，没做